五、用两个栈实现队列：

用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。



解题思路：队列FIFO，栈FILO。当一个元素入队时，直接压进栈1；当有元素要出队，将栈1中全部的元素压进栈2，栈2的栈顶元素即为最初入队的元素。



***

二十、包含min函数的栈：

定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。



解题思路：

- - 用两个栈来存，一个正常存储，另一个如果入栈元素小于**或者等于**栈顶元素再入栈，即栈顶元素始终最小。
  - 出栈时，两个栈顶相等，则全pop，否则只pop第一个栈。



***

**二十一、栈的压入，弹出序列：**

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）



解题思路：我认为可以从题目中找到思路，就是研究的栈的问题，八成要构建辅助栈，当然构建几个暂时栈不确定，但是一个思路。



```C++
/*

借用一个辅助的栈，遍历压栈顺序，先将第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，

​    这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，

​    这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。

举例：

入栈1,2,3,4,5

出栈4,5,3,2,1

首先1入辅助栈，此时栈顶1≠4，继续入栈2

此时栈顶2≠4，继续入栈3

此时栈顶3≠4，继续入栈4

此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3

此时栈顶3≠5，继续入栈5

此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3

….

依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序。

*/
```

***

六十四、滑动窗口的最大值：

给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。



解题思路：我就是暴力解的，算了算，大概O(3n)复杂度，好像也还行。每次找到一个头，遍历size个大小的窗口值，记录最大值，push到vector中就行。注意边界条件，**窗口大小和数组大小**。