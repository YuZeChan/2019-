**十一、二进制中1的个数：**

输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。



注意：**x&(x-1)的作用是统计x中的1的个数，x|(x+1)的作用是统计x中的0的个数。**

***

十二、数值的整数次方（代码完整性）：

给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。



注意：exponent为负的情况。



***

三十一、整数中1出现的次数（从1到n中1出现的次数）：

求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。



emmm放弃了！



***

三十三、丑数：

把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。



解题思路：这个题解释起来其实也很困难，我只能说大概能看懂，这种找规律的题如果问到，一定要给出思路，但是写不写得出来，全看运气。

```C++
int GetUglyNumber_Solution(int index) { 
    // 0-6的丑数分别为0-6 if(index < 7) 
    return index; 
    //p2，p3，p5分别为三个队列的指针，newNum为从队列头选出来的最小数 
    int p2 = 0, p3 = 0, p5 = 0, newNum = 1; 
    vector<int> arr; arr.push_back(newNum); 
    while(arr.size() < index) {      
        //选出三个队列头最小的数     
        //首先min只能针对两个数，另外，已经选出来的数，对应的质因子指针后移，表示不再计算     
        newNum = min(arr[p2] * 2, min(arr[p3] * 3, arr[p5] * 5));     
        //这三个if有可能进入一个或者多个，进入多个是三个队列头最小的数有多个的情况     
        if(arr[p2] * 2 == newNum) p2++;     
        if(arr[p3] * 3 == newNum) p3++;     
        if(arr[p5] * 5 == newNum) p5++;     
        arr.push_back(newNum);     
    } 
    return newNum; 
}

```



***

四十八、不用加减乘除做加法：

写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。



解题思路：

- - 两个数异或：相当于每一位相加，但不考虑进位
  - 两个数相与：相当于求进位
  - 再将两个数异或。

​    

```C++
while(num2 != 0){            
    int sum = num1 ^ num2;        
    int carry = (num1 & num2) << 1;   
    num1 = sum;         
    num2 = carry;    
}        
return num1; 
```

