##### **1、超时重传**：

重传超时是TCP协议保证数据可靠性的另一个重要机制，其原理是在发送某一个数据以后就开启一个**计时器**，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据，直到发送成功为止。



***

##### **2、TCP三次握手：**

当某个主机开启一个TCP会话时，他的初始序列号是**随机的**，可能是0和4,294,967,295之间的任意值，但一般抓包工具显示的是相对序列号（一般为0），而非绝对序列号。

原因：（**安全因素**）如果不是随机产生初始序列号，黑客将会以很容易的方式获取到你与其他主机之间通信的初始化序列号，**并且伪造序列号进行攻击**，这已经成为一种很常见的网络攻击手段。



***

##### 3、TCP中的RST复位信号：

在TCP协议中，RST表示复位，用来关闭异常的连接。

- 用RST包来关闭连接时，不必等缓冲区的包都发过去，而是直接丢弃，直接发送RST包。

- 接收端收到RST包就直接关闭连接，不必发ACK来确认。



产生RST的原因：

1. 端口未打开（**这种情况很常见，特别是服务器宕机的情况**）：服务器程序端未打开，而客户端来连接，如telnet，可能发生错误。如主机A向主机B发送SYN请求，想要连接B的40000端口，但主机B根本没打开40000端口，于是B会向A发送一个RST。
2. 提前关闭：比如主机A和主机B正常建立连接后，A向B发送了FIN包要求关连接，B发送ACK后，**网断了（这个也忒逗了）**，A通过若干原因放弃了这个连接（例如进程重启）。网通了后，B又开始发数据包，A收到后表示压力很大，不知道这野连接哪来的，就发了个RST包强制把连接关了，B收到后会出现connect reset by peer错误。
3. 在一个已关闭的连接上受到数据
4. 请求超时



***

##### 4、HTTP、Socket、TCP的区别：

这三个概念经常被谈到，也是比较容易被混掉的概念。在回顾之前我们先看一下这三者在TCP/IP协议族中的位置关系：

![img](/resources/层次关系.png)



HTTP是应用层的协议，更靠近用户端；TCP是传输层的协议；而socket是从传输层上抽象出来的一个抽象层，本质是接口。所以本质上三种还是很好区分的。尽管如此，有时候你可能会懵逼，HTTP连接、TCP连接、socket连接有什么区别？好吧，如果上面的图解释的还是不够清楚的话，我们继续往下看。



1、TCP连接与HTTP连接的区别

- 上文提过，HTTP是基于TCP的，客户端往服务端发送一个HTTP请求时第一步就是要建立与服务端的TCP连接，也就是先三次握手，“你好，你好，你好”。从HTTP 1.1开始支持持久连接，也就是一次TCP连接可以发送多次的HTTP请求。

- 小总结：HTTP基于TCP



2、TCP连接与Socket连接的区别

- 在图4.1中我们提到，socket层只是在TCP/UDP传输层上做的一个抽象接口层，因此一个socket连接可以基于连接，也有可能基于UDP。基于TCP协议的socket连接同样需要通过三次握手建立连接，是可靠的；基于UDP协议的socket连接不需要建立连接的过程，不过对方能不能收到都会发送过去，是不可靠的，大多数的即时通讯IM都是后者。
- 小总结：Socket也基于TCP



3、HTTP连接与Socket连接的区别

- 区分这两个概念是比较有意义的，毕竟TCP看不见摸不着，HTTP与Socket是实实在在能用到的。
- **HTTP是短连接，Socket(基于TCP协议的)是长连接。**尽管HTTP1.1开始支持持久连接，但仍无法保证始终连接。而Socket连接一旦建立TCP三次握手，除非一方主动断开，否则连接状态一直保持。
- **HTTP连接服务端无法主动发消息，Socket连接双方请求的发送先后限制。**这点就比较重要了，因为它将决定二者分别适合应用在什么场景下。HTTP采用“请求-响应”机制，在客户端还没发送消息给服务端前，服务端无法推送消息给客户端。必须满足客户端发送消息在前，服务端回复在后。Socket连接双方类似peer2peer的关系，一方随时可以向另一方喊话。



4、问题来了：什么时候该用HTTP，什么时候该用socket

- 这个问题的提出是很自然而然的。当你接到一个与另一方的网络通讯需求，自然会考虑用HTTP还是用Socket。
- 用HTTP的情况：**双方不需要时刻保持连接在线**，比如客户端资源的获取、文件上传等。
- 用Socket的情况：**大部分即时通讯应用(QQ、微信)、聊天室、苹果APNs等。**



***

##### **5、TCP三次握手和四次挥手：**

​	**对于建链接的3次握手（这么看他的解释是对的，我一开始背的那个虽说也没错，但是不是最主要的症结所在）**，主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）

​	**对于4次挥手**，其实你仔细看是2次，因为TCP是全双工的，所以，发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。**如果两边同时断连接，那就会就进入到CLOSING状态**，然后到达TIME_WAIT状态。

