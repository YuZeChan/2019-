1、vector为什么不能存引用：

​	《C++ primer》上说 vector 中不能存放引用的原因是：**引用不支持一般意义上的赋值操作**，而 vector中元素的两个要求是：１.元素必须能赋值２.元素必须能复制

容器中保存的是“值”而非“引用”。
向容器中执行插入时，**会执行值拷贝**，因为引用必须在定义时指定引用对象且不允许改变使其指向其它对象，所以不能存放“引用”类型。

至于函数声明/定义中的引用，是参数的一种传递方式。只有在执行函数调用时才会为其分配空间，即在调用时才是实际定义，而此时会通过实际参数对其进行初始化。



**补充：auto_ptr和shared_ptr可以存在vector中吗？**

​	**前者不可以，后者可以，因为元素必须可被构造和转移赋值（具体看C++11新特性总结）。**

***

2、vector相关：

扩容方式：双倍扩容法，够用及直接在后面开辟，不够用开辟二倍空间再拷贝过来。

clear（）方法不释放空间，析构时才释放。swap（）强制交换，也会造成释放。

插入的方式：insert，emplace_back，push_back。

删除：erase，clear（原来有10个元素的空间，clear后仍有10个空间）

补充：

**insert和emplace区别：**
	emplace支持用插入对象的构造函数就地构造，比先用构造函数构造出对象，传入insert再一次拷贝构造的两次过程节省一次。



**vector的实现：**

![vector实现](/resources/vector实现.jpg)

***

补充实际使用时的问题：

```C++
//vector<vector<int>> v(5);这样初始化是预分配五个长度为零的vector<int>，不能直接访问如v[0][3]，但可以v[0].push_back(1);
vector<vector<int> > v1(5);
v1[0].push_back(1);
//无初始化，v2.size() == 0;
vector<vector<int> > v2;
vector<int> v;
v.push_back(1);
v.push_back(2);	
//v1.push_back(v);
v2.push_back(v);
cout << v1.size() << v1[1].size() << v1[0][0] << v2.size() << v.size();
//得到的结果为5,0,1,1,2

vector<int> v({0,1,2,3,4,5})；
//可以直接静态初始化。。。头疼啊，各种方式竟然都行。。。
```



***

3、map/set (红黑树):

高度接近平衡的二叉树：结点红黑，根叶为黑，红子为黑，同根出发到叶的路径黑个数相同。

插入删除：**调整在2-3次**，比AVL树优越。

存的是带数据的节点，O(log N)；

hashmap：底层是散列表，拉链法（这里没用线性探查法），O(1+K)。

***

4、deque：

**双向开口的数组，开辟连续空间，用链式结构链起来**。

一个数组快连着下一个数组快。

需要重载++操作符。

***

5、priority_queue：

#include<queue>中，构造函数priority_queue<int ,vector<int> , less/greater<int>>;

less是最大堆，greater是最小堆。

底层是**堆**；

***

6、stack、queue：

容器适配器：规定了运行方式的容器，用deque实现。

stack先入后出：树的前中序遍历使用辅助栈，递归调用可用栈改写。

queue先入先出：广度优先遍历

***

7、STL内存分配器？

使用allocate向内存池请求大小为size的内存空间。

- SGI STL的内存池（STL是一个标准，各商家根据这个标准开发了各自的STL版本。SGI为一个STL版本）
- 超过128bytes 第一级配置器 直接malloc
- 小于128bytes 第二级配置器
- 16个链表管理，从8bytes到128bytes，每次申请内存从对应链表中拔出内存块，如果链表为空，向内存池取20个区块，或取剩下个数的区块（不足20），仍然不行就分配内存池零头，内存池重新分配请求堆上内存，为两倍的请求内存加上一个随请求次数增加的值。如果不够则找大的区块挖一块使用，如果还不行就调用一级配置器的out of memory处理机制