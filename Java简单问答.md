#### **1、反射机制**

说到反射要从"正"开始解释，一般而言，当用户使用一个类的时候，应该先知道这个类，而后通过这个类产生实例化对象，但是“反”指的是通过对象找到类。

反射基本上要答到动态编译，思想就是要解耦，比如支付：用支付宝，微信，银联。。。需要一个个if else判断写代码，很蠢，维护（修改）的时候也需要改源码，这样不方便。

**反射机制提供的主要功能****：**

- 在运行时判断任意一个对象所属的类。
- 在运行时构造任意一个类的对象。
- 在运行时判断任意一个类所具有的成员变量和方法。
- 在运行时调用任意一个对象的方法





***

#### **2、动态代理机制：**

解释动态代理之前首先解释什么是代理：当有些类的对象，我们不希望他的内容被修改，甚至不希望他的内容被直接访问，所以就要用的代理（由于权限设置）。这时候，通过代理对象，可以在客户和对象间起到中介的作用。

有时候，代理对象除了访问真实对象的能力（有时会在前后增加一些额外的功能），还有操作或修改真实对象的能力。

静态代理：一个代理类只能代理一种类型的对象，对于代理多个方法时，则需要许多代理类。

不支持扩展，被代理类增加某种方法，代理类也要相应处理。

动态代理（仅仅支持代理interface）：为一组接口动态的生成代理类和代理对象。通过反射的方式，生成代理类和代理对象，即动态代理能代理多个接口。

getInvocationHandler（）getProxyClass（）



举个例子：被代理的类对象就好比是明星，明星的信息时隐藏的，或者无法知晓。你无法直接访问明星，你必须通过明星的经纪人来联系业务，经纪人就是个代理。

而静态代理代表着一个经纪人代理一个明星

而动态代理，是一个经纪人代理许多明星，只要你知道你想访问的明星是谁，他就能通过这个信息找到那个明星，然后反馈给你。





***

#### **3、java虚拟机:**

- jvm内存模型：方法区（类信息，常量，静态变量，class文件），堆区（存储各种对象实例），虚拟机栈，本地方法栈（不一定是Java语言编写的方法），程序计数器。

- jvm垃圾处理机制：标记清除、标记整理、复制、分代收集。

- 垃圾收集器：G1

- 区分对象是否gc：引用计数，可达性分析(root线程)

- - 强引用，软引用，弱引用，虚引用。

- java类加载步骤(类的生命周期)：加载，验证，准备，解析，初始化，使用，卸载。

- jvm的生命周期：Java程序开始执行到其运行结束。（**每个Java程序都会单独运行一个jvm**）



***

#### 4、Object类的固有方法：

- toString()
- equals()//判断同一（两个引用是否指向同一对象），需要重写才可判断是否内部相等
- hashCode()
- clone()
- finalize()用来释放非java代码开辟的内存
- getClass()
- notify() / notifyAll() / wait()