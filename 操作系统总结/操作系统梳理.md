#### **这边主要写一些自己对于操作系统原理上的理解：**

总的来说，操作系统（os）是人们开发的用于将不好理解的硬件信息，转化为人们可以理解和方便使用的可视化模型。**是对硬件的一种抽象**！

***

##### **1、综述部分：**

在os中，抽象主要分为三大部分：

​	1、CPU-----》进程

​	2、硬盘-----》文件系统

​	3、内存-----》地址空间（物理地址空间，逻辑地址空间）



os的内核具有四种特性：并发（**CPU**），共享（内存），虚拟（硬盘），异步（程序“走走停停”地运行）



虚拟机其实是对硬件资源过剩的一种利用，虚拟机的os认为其是独立的个体，感受不到虚拟。



os启动的过程：

POST---》BIOS---》BootLoader---》DISK---》OS加载到内存

POST（加电自检，寻找显卡和执行BIOS）

BIOS（Basic I/O System）检测外设并加载各种软件的执行

BootLoader（512字节）存放os的起始地址，加载os

DISK存放os



os的接口分为两种：

对应用程序：系统调用（**主动**）和异常（**被动**）

对外设：中断和I/O



对于中断和异常：

当os检测到异常或者中断请求的时候：（**对于应用程序来说，感受不到中断和异常**）

先保存现场---》中断/异常处理---》恢复现场



CPU的运转状态：用户态（App）和内核态（OS），两者有特权级和堆栈的不同



程序访问os请求服务主要通过跟高级的API，而不是直接通过系统调用。（如win32，POSIX）

***

##### **2、OS与内存：**

**内存---》地址空间**



首先需要介绍CPU的内部结构：ALU（逻辑计算单元）、寄存器（专用和通用）、控制器、缓存、MMU（存储管理单元）



OS管理内存的方法：程序重定位，分段，分页，虚拟内存



逻辑地址空间：一个运行的程序所占用的内存范围0~MAXprog



**MMU**存储了一个逻辑地址和物理地址的映射表，这个表由OS所建，MMU负责存储和查询。



一段C语言代码是如何一步步进行编译并加载近内存的：

.c--->.s--->.obj--->.exe--->loader（程序重定位）---> 内存（逻辑地址）

.obj文件称为可重定位文件，包含了编译单元中的所有函数，数据，导出符号表，未解决符号表和地址重定向表。

库文件，又称可共享文件，适合于在上下文里链接的代码和数据。

lib静态库，是obj文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。

dll动态库，可认为是一个没有main函数的exe文件。将它与另一个可执行文件及其它的共享目标文件结合到一起，创建一个进程映象。



段的实质是一个内存块，段表（段号s + 段内偏移add）



页：物理分为帧frame，逻辑分为页page。

位于内存中的页表来建立对应关系，MMU和**TLB（常用的放在Cache中，访问速度快）**中。

多级页表：解决页表很大，一个页框放不下的情况。



虚拟内存：virtual memory = physical memory + disk

以页为单位，进行内外存交换

**缺页中断：内存到硬盘的读写操作**



程序存在局部性原理，有助于设计页面置换算法。



页面置换算法实际上是因虚拟内存发展的需要而被设计的（**分配的物理页面一般少于程序所需的总页面，所以需要置换**）：

局部（分配的物理页帧数不变）：

最优页面置换算法（下次访问时间最远的换出去，理想化，无法实现，只作为评价标准）

先进先出FIFO（**有Belady现象：分配的物理页面增加，但缺页率却上升**）

最久未被使用（LRU）

时钟页面置换算法（CLOCK）

二次机会法

最不常用（LFU）

全局（分配的物理页帧数可变）：工作集和缺页率页面置换算法

***

##### **3、OS与CPU：**

**CPU---》进程**



进程：一个（或几个）具有一定独立功能的程序在一个数据集合上的一次动态执行。

进程包括：程序、数据、进程控制块PCB（Process Control Block，进程的唯一标识、可以理解为OS为描述进程而维护的一个数据结构，PCB由类似链表来存储）



进程的生命周期：创建，运行，等待（阻塞），唤醒（就绪），（有时还有个僵尸zombie），结束。



进程的创建：由**系统**初始化，**用户**请求创建，由**父进程**产生。



**进程只能自己阻塞自己，进程只能被os或者其他进程唤醒。**



五个基本状态和生命周期对应：创建，运行，就绪，阻塞，结束。

![img](/resources/进程生命周期.png)



进程挂起（**事实上是虚存管理内的概念**）：由于机器的资源是有限的，操作系统将进程暂时被淘汰出内存，**此时进程不占内存，而是映像到磁盘上。**

不同状态的OS维护一个或者多个队列管理和组织PCB。



线程：更小，但可以独立运行的基本单位，**是进程中的一条执行流程**。（Thread Control Block，TCB储存线程信息，唯一标识）



线程**并发运行，共享资源**。

线程间除了**寄存器和栈独立**，其余的堆、代码段、数据段、文件、全局变量、静态变量等均共享。



进程与线程的比较：

进程：整合资源，构成一个**资源平台**（地址空间，打开文件等等）。

线程：代码在这个资源平台上的一条**执行流程**。

**进程是资源分配的单位，线程是CPU调度的单位。**

线程 = 进程 - 共享资源



单进程单线程：MS-DOS       单进程多线程：Unix        多进程多线程：Linux，Windows



线程的种类：用户线程，内核线程，轻量级线程。



上下文切换：停止当前运行的进程，并且调度其他的进程。



**fork（）父进程创建子进程，完全复制包括地址空间，但不会递归进行。**

**父进程帮助所有其创建的子进程回收所有资源并释放。**



CPU调度：从就绪队列中选择一个进程/线程进入cpu运行，分为抢占式和不可抢占式。

CPU调度的算法：FCFS先来先服务、短服务优先、最高响应比优先、轮循、多级反馈队列、公平共享调度（主要用在服务器中）。



CPU调度算法的评价标准：利用率，吞吐量，周转时间，等待时间，响应时间。



同步互斥：多道程序设计，访问共享资源。

临界区（本质是一段代码）：一个进程进入临界区执行，其他进程进来但不执行。

每个进程中访问[临界资源](https://baike.baidu.com/item/%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90)的那段代码称为临界区（Critical Section）（临界资源是一次仅允许一个进程使用的共享资源）。----------转自百度百科

临界区的性质：互斥，有限等待。



信号量（本质是一个抽象的数据类型）和管程用来实现同步互斥。

**生产者消费者模型，读者写着模型，哲学家就餐问题。**



死锁：集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，若无外力作用，它们都将无法推进下去，那么该组进程是死锁的。

**银行家算法**



​	进程间通信：

- - 直接：信号、共享内存；
  - 间接：管道、消息队列。

***

##### **4、OS与硬盘：**

**硬盘---》文件系统**



文件系统：一种用于持久性存储的系统抽象。**在存储器上组织、控制、导航、访问和检索数据**。



文件描述符：**内核跟踪每个进程打开的文件**。OS为每个进程维护一个打开文件表，一个打开文件描述符（file descriptor，维护在进程PCB中）是这个表中的**索引**。



元数据：文件指针，打开文件计数，文件磁盘位置，访问权限。



空闲空间管理：**位图**代表空闲数据列表（定期修改跟新），链式列表，分组列表。



磁盘调度：进程不断发出读写磁盘请求，且比磁盘的响应速度快，因此为每个磁盘设备建立了一个等待队列，并由特定算法来统筹调度。

磁头---》（寻道时间）---》磁道---》（旋转延迟）---》扇区---》数据访问

磁盘调度策略：

​	先进先出，

​	短服务优先，

​	扫描算法（向一个方向），

​	循环扫描，

​	c_lock（到最后一个请求处立刻反转）



IO系统的两种趋势：硬件与软件接口日益标准化，IO设备日益多样性。



设备驱动程序：控制设备的内核模块，**实际上是os与硬件的接口**。

***



补充：

设备驱动程序 ≈ 系统调用 （只是主体不同）

PCI（Peripheral Component Interconnect外设部件互连标准）总线：连接CPU、内存、快速设备。

中断请求线（IRL）：**CPU执行完每条指令都检查一次**。

​	中断请求->保存现场->处理->返回

设备-> 设备控制器-> 设备驱动-> 内核I/O子系统-> 内核。

