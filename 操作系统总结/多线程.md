### 多线程：

***

一个程序的运行过程中，只有一个控制权的存在。

- 如果一个函数被调用，那么该函数获取控制权，成为激活（active）函数，然后运行该函数中的指令。
- 此时其他函数处于离场状态，并不运行。

多线程，就是允许一个进程处在多个控制权，可使得多个函数同时处于激活状态，多个函数操作可以同时运行。**即使是单核计算机，也可通过不停在不同线程的指令间切换，来达到“同时”运行的结果**。

![1554531179501](/resources/多线程.jpg)



##### 多线程的栈：

栈的定义时**<u>一进一出</u>**，适合单线程。只有一个进出口不适合多线程。

要实现多线程，须绕开这个限制，为每个线程创建一个栈（实际也是这么做的）。

在多线程的进程中，存在多个栈，**每个线程对应一个栈**，多个栈间以一定的空白区域隔开。都是由高地址向低地址扩张（最下方读写）。

**但任何一个空白区域被填满都会造成栈溢出。**

***

##### 上下文切换的资源浪费：保存现场和恢复

对于每个进程，**系统资源**看上去都是其独占（每次切换，内存中的“独立资源”也要切换）。

一开始不太懂，想想大概是，**CPU拷贝cache和寄存器**，堆栈切换等动作消耗时间。

多线程省去切换的开销，也便于通信。



***

##### 多线程的创建与结束：

```C++
#include<pthread.h>
typedef unsigned int pthread_t  
```

可以经常看到这样的定义，很多结构最后都是unsigned int型

```C++
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void* (*start_routine)(void*), void *arg);
//第一个参数是——指向线程标识符的指针
//第二个参数是——设置线程属性
//第三个参数是——线程运行函数的其实地址
//第四个参数是——对运行函数传入的参数
//返回值是——0：成功；编号：失败
```

成功后，thread指向的内存单元将被设置为新创建线程的ID（也是无符号整型）

```C++
int pthread_join(pthread_t thread, void** retval);
//join函数用来等待一个线程的结束，使之“顺序”执行。
//一般为主线程调用，等待子线程结束（阻塞的）

void pthread_exit(void *retval);
//子线程调用，用来结束当前线程

```

​	如果线程调用的函数在一个类中，应该把它设为**静态成员函数**（估计也和this指针有关）。

如何获取线程的id：

- pthread_self()
- 创建时生成

多线程的重入（_REENTRANT）：

- 可重入函数：指可以由一个或多个任务并发使用，而不用担心过数据错误的函数
- 方式：无静态数据，全局变量加锁，不调用不可重入函数。



***

##### 线程的属性：

![线程的属性](/resources/线程的属性.jpg)

线程的属性被封装在一个结构体中，可用来设置一组属性。

这些值均要用pthread_attr_init()函数来设置。

默认属性：非绑定，非分离，1MB的堆栈，与父进程同优先级。



**分离状态是指：**

- 当线程终止时，系统将不保留线程终止的状态。

- （即设为detached，当一个分离状态的线程使用join时会出错，因为终止的状态都没保留，系统根本不知道线程什么时候结束，难道一直阻塞在那嘛=。=）

调度策略：

- 先入先出
- 循环
- 自定义



***

#### 线程的同步互斥：

同步：多线程程序中，在同一时间内，只允许某一个线程访问某个资源。

实现同步的方法：

- 互斥锁——mutex
- 条件变量——condition variable
- 读写锁—— reader-writer lock
- 信号量——semaphore



##### 1、互斥量：

是一种特殊的变量，有lock和unlock两个状态。一般设为全局变量。

```C++
pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_init
pthread_mutex_destroy
pthread_mutex_lock
pthread_mutex_unlock
pthread_mutex_trylock//有锁时获取，无锁返回EBUSY（非阻塞的）
```



##### 2、条件变量：

有些情况互斥量无法很好解决：比如，某线程正在等待共享数据内的某个条件出现，它可能重复对互斥对象加锁和解锁，每次检查共享数据都要这样。效率极低，浪费时间和资源。

解决方法：当线程等待某些条件满足时，线程进入睡眠状态；一旦条件满足，就唤醒因等待而睡眠的线程。

条件变量（<u>**须和互斥量一起使用**</u>）：

- 使用时，条件变量用来阻塞一个线程（睡眠）。
- 当条件不满足时，线程解开相应的互斥锁，并等待条件发生变化。
- 一旦其他线程改变了条件变量，它通知唤醒一个或多个正在被当前条件变量阻塞的线程，这些线程将重新锁定互斥锁，并检查条件是否满足。

```C++
pthread_cond_t()
pthread_cond_init()
pthread_cond_destroy()//须当没有线程在此阻塞时才能注销
//与互斥锁配合，以防止多个线程同时请求wait，调用前须由当前线程加锁。
pthread_cond_wait()//条件等待
pthread_cond_timedwait()//计时等待

pthread_cond_signal()//脱离阻塞，继续执行
    //最多只给一个发信号，无惊群现象（每当有资源可用，所有进/线程都来竞争）
```



##### 3、读写锁：

读锁共享锁，写锁排它锁。

策略分类：

- 强读者同步：有读先读
- 强写着同步：有写先写

读锁加锁：读可访问，写被阻塞。

写锁加锁：当前写者可写，其他均被阻塞。

```C++
pthread_rwlock_init();
pthread_rwlock_destroy();
pthread_rwlock_rdlock();
pthread_rwlock_wrlock();
pthread_rwlock_unlock();
pthread_rwlock_trylock();
```



##### 4、信号量：

信号量与互斥量的区别：允许多个线程同时进入临界区。

命名“sem_~”

```C++
int sem_init(sem_t *sem , int pshared , unsigned int value);
//pshared为0表示当前进程局部信号量，否则是多个进程（有点骚啊）中共享。。。
sem_wait();//这两个都是原子操作，信号量-1
sem_post();//信号量+1
sem_destroy();
```

