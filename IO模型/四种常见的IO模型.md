### 四种常见的IO模型：

***

首先明确几个概念：

- 常见的IO设备：
  - 打印机，键盘，显示器
  - 硬盘，磁盘，U盘
  - 网卡，路由器
- IO的两种操作：
  - 同步IO：等待IO完成后，再将控制权交还给用户进程
  - 异步IO：无需等待IO完成，直接将控制权交给用户进程



***

**网络中的IO：**由于不同IO设备的特点，以及网络通信的特点，往往需要**<u>等待</u>**。

等待分为以下四个部分：

- 输入操作：等待数据到达socket接收缓冲区
- 输出操作：等待socket的发送缓冲区有足够的空间容纳将要发送的数据
- 服务器接收连接请求：等待新用户连接请求的到来
- 客户端发送连接请求：等待服务器回复SYN的ACK



***

当一个网络IO(以read为例)发生时，将涉及到两个系统对象：

- **调用IO的用户进程**
- **系统内核。**



read()的阶段：

- 等待数据的准备
- 将数据从内核拷贝到用户内存中



***

##### 四种网络IO模型：

- 同步IO：
  - 阻塞IO：IO操作需要**彻底完成后**，才返回用户空间。用户进程在此过程中阻塞，切换到内核处理，等待数据就绪**且**拷贝到用户内存后，再换新用户进程。
  - ![阻塞IO](/resources/阻塞IO.jpg)
  - 非阻塞IO：**立即返回给用户一个状态值**，不需IO彻底完成。但这个过程其实是**忙轮训**，用户进程不断询问kernel内核是否已经准备好数据。当数据准备好时，用户调用recvfrom，内核将数据从内核拷贝到用户内存，此时用户内存处于阻塞状态，完毕后才唤醒用户进程。
  - ![非阻塞IO](/resources/非阻塞IO.jpg)
  - 多路复用IO（事件驱动IO）：**存在一个函数（如select）来不断询问其负责监控的socket**，当某个socket有数据到达了，就通知用户进程，select返回前，用户进程阻塞。
  - ![多路复用IO](/resources/多路复用IO.jpg)
- 异步IO：用户进程read请求后，直接去做其他事情；内核收到read请求直接返回用户态，**不阻塞用户进程**；当内核收到数据**并**拷贝到用户内存中后，再通知用户进程read操作。

![异步IO](/resources/异步IO.jpg)





**原来我一直认为是四种同步，异步，阻塞，非阻塞IO的排列组合，现在看不是这样。**

![四种IO比较](/resources/四种IO比较.jpg)

***



大部分socketIO接口（甚至扩大到大部分IO接口），都是阻塞型的，它们会在得到数据或者超时后才返回用户进程。



前期，在服务端采用多线程（多进程），是阻塞的连接不影响其他连接。

- 多进程和多线程没有明确的区别，只是适用的场景不同
- 多进程：强调安全，在计算量大或者文件访问多时使用，fork（）
- 多线程：用户量大时使用，这是多进程开销太大，pthread_create（）

```C++
int accept(int fd, struct sockaddr *addr , socklen_t *addrlen) ; 
//输入参数fd是从socket()、 bind()和listen()中沿用下来的socket句柄值。
//accept返回一个新的socket，所以看似一个socket可以accept多次。
//accept()是从socket fd的请求队列中抽取第一个连接信息
```



改进，线程池或者连接池，减少不停创建和销毁线程的频率，但池的大小终归有限，这两种方法也只用于小规模的服务请求。



***

##### 用户调用select的过程：

1. 用户进程调用select
2. 进程阻塞，由内核监控select负责的socket
3. 任何一个socket准备好，select返回，唤醒用户进程
4. 用户read，数据从内核拷贝到用户内存



可以发现，select存在两个系统调用，select和recvfrom，**效率并没有提高**。

但是优点是可以同时处理多个连接。



所以对于连接数较少的webserver，阻塞IO的效果可能会更好。比如延迟小。



用户进程被select阻塞，而**非**被socket IO阻塞，所以称为**同步非阻塞**。



```C++
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds , struct timeval *timeout);
//fd_set按bit位标记句柄的队列
//readfds 、 writefds 和 exceptfds 同时作为输入参数和输出参数
//分别监视：可读，可写，异常/错误，三个事件
//客户端的一个connect()操作，将在服务器端激发一个“可读事件”，所以 select()也能检测来自 客户端的 connect()行为。也可检测connect()事件
```

当select()捕捉到事件时，**程序员**需要检查**所有**标记位(FD_ISSET函数)，以确定到底哪些句柄发生了事件。

对服务器而言：

- 可读事件 =》recvfrom()
- 可写事件 =》send()



当执行体很大时，select会使之后的事件饥饿。

Linux 2.6之后，引入异步IO，如aio_read, aio_write。



***

