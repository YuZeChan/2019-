### STL底层数据结构实现：

***

STL包括几个部分：容器，算法（泛型算法），迭代器三个主要部分（当然还包含仿函数，适配器等其他部分），下图说明了三个主要部分之间的关系（*网图，侵删*）。

![stl](/resources/stl.png)



##### 1.vector      

##### 底层数据结构为数组 ，支持快速随机访问

**扩容规则：**

​	当我们新建一个vector的时候，会首先分配给他一片连续的内存空间，如`std::vector<int> vec`，当通过push_back向其中增加元素时，如果初始分配空间已满，就会引起vector扩容，其扩容规则在gcc下以2倍方式完成：

- 首先重新申请一个2倍大的内存空间；
- 然后将原空间的内容拷贝过来；
- 最后将原空间内容进行释放，将内存交还给操作系统；



**平均拷贝次数：2**

首先向vector插入元素实际上是一次复制；当发生二倍扩容时，当前元素被复制一次，之前的一半元素被复制两次，再一半的一半被复制3次，取极限lim(1 + 2 * n/2+3 * n/4 + ……)/n = 2。



**注意事项：**
根据vector的插入和删除特性，以及扩容规则，我们在使用vector的时候要注意，**在插入位置和删除位置之后的所有迭代器和指针引用都会失效，同理，扩容之后的所有迭代器指针和引用也都会失效。**

![vector实现](/resources/vector实现.jpg)



***

##### 2.list           

#####  底层数据结构为双向链表，支持快速增删





***

##### 3.deque       

底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问

> deque是一个双端队列(double-ended queue)，也是在堆中保存内容的.它的保存形式如下:
>
> **[堆1] --> [堆2] -->[堆3] --> ...**
>
> 每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list和vector的结合品.



***

##### 4.stack        

底层一般用**list或deque实现**，封闭头部即可。

**不用vector的原因应该是容量大小有限制，扩容耗时。**



***

##### 5.queue     

底层一般用**list或deque实现**，封闭头部即可。

不用vector的原因应该是容量大小有限制，扩容耗时。



（stack和queue其实是**适配器**,而不叫容器，因为是**对容器的再封装**）



***

##### 6.priority_queue     

优先级队列的底层数据结构一般为**vector为底层容器**，**堆heap为处理规则**来管理底层容器实现

优先级队列相当于一个**有权值**的单向队列queue，在这个队列中，所有元素是按照优先级排列的。



***

##### 7.set

底层数据结构为**红黑树**，有序，不重复



##### 8.multiset         

底层数据结构为**红黑树**，有序，可重复 （我猜每个节点存的是链表。。。）



***

##### 9.map                

底层数据结构为**红黑树**，有序，不重复



##### 10.multimap    

底层数据结构为**红黑树**，有序，可重复



***

11.hash_set （unordered_set）    

底层数据结构为**hash表**，无序，不重复

之所以无序，是因为**hash会把所有的key打乱**，使得没有顺序。



12.hash_multiset （unordered_multiset）

底层数据结构为**hash表**，无序，可重复 



13.hash_map    （unordered_map）

底层数据结构为**hash表**，无序，不重复



14.hash_multimap （unordered_multimap）

底层数据结构为**hash表**，无序，可重复 