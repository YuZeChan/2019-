##### **解决复杂问题的方法：**

分解（将复杂问题分成很多小问题分别解决）、抽象（通过某种方法统一解决，忽视分本质细节，从更高层次来解决问题）



软件设计的目标：

软件设计的的金科玉律：复用



**设计模式六大原则：**

1. 单一职责原则(Single Responsibility Principle, SRP)：一个类**只负责一个**功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。
2. 开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对**扩展开放，对修改关闭**。即软件实体应尽量在不修改原有代码的情况下进行扩展。
3. 里氏代换原则(Liskov Substitution Principle, LSP)：所有引用基类（父类）的地方必须能透明地使用其派生类（子类）的对象（**子类对象能无害地替换父类对象**）。
4. 依赖倒转原则(Dependency Inversion  Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要**针对接口编程**，而不是针对实现编程。
5. 接口隔离原则(Interface  Segregation Principle, ISP)：客户端不应该依赖它不需要的借口。（或者这一这样说：**类的依赖应该建立在最小的接口上**。）
6. 迪米特法则(Law of  Demeter, LoD)：一个软件实体应当**尽可能少**地与其他实体发生相互作用。“只跟直接的朋友进行沟通”；“不跟陌生人说话”；“对其他的单位了解的越少越好”



**常用的设计模式可概括为23种，根据其特点可分类为三大类型：**

一、创建型：1.单例模式，2.工厂方法模式，3.抽象工厂模式，4.建造者模式，5.原型模式

二、结构型：6.代理模式，7.装饰模式，8.适配器模式，9.组合模式，10.桥梁模式,11.外观模式，12.享元模式

三、行为型：13.模板方法模式，14.命令模式，15.责任链模式，16.策略模式，17.迭代器模式，18.中介者模式，19.观察者模式，20.备忘录模式，21.访问者模式，22.状态模式，23.解释器模式



##### **c++设计模式：**

**简单工厂模式：**

工厂模式有一种非常形象的描述，建立对象的类就如一个工厂，而需要被建立的对象就是一个个产品；在工厂中加工产品，使用产品的人，不用在乎产品是如何生产出来的。从软件开发的角度来说，这样就有效的降低了模块之间的耦合。

使用情景： 

在不确定会有多少个处理操作时应该考虑使用简单工厂模式，如针对同样的接收到的数据，处理的逻辑可能会不同，可能以后还会增加新的操作。 

案例： 

如果实现计算器的功能时，对于同样的输入数据，可能执行加、减、乘、除，甚至其他的功能。因此可以抽象出一个操作的抽象类或是接口，提供一个统一的处理方法(此处为process)，然后每种操作创建出一个子类出来。而判断具体使用哪个具体的实现类是在工厂类中进行判断的(将存放操作的变量传递给工厂的生产方法)。工厂类始终返回的是这个抽象类，这样如果对原有功能进行更改或是新添加新的功能，也不会对原来的其他类做修改，只编译修改的那个类或是新的类就可以了。 

这样就做到了把耦合降到最低，同时也便于维护。 

 

 

简单工厂：把对象的创建放到一个工厂类中，通过参数来创建不同的对象。这个缺点是每添一个对象，就需要对简单工厂进行修改（尽管不是删代码，仅仅是添一个switch case，但仍然违背了“不改代码”的原则）

工厂方法：每种产品由一种工厂来创建，一个工厂保存一个new。基本完美，完全遵循 “不改代码”的原则。

抽象工厂：仅仅是工厂方法的复杂化，保存了多个new。大工程才用的上。



**举例说明三者的区别：（写的不错）**

1. 简单工厂模式：定义一个工厂类，根据参数的不同返回不同类的实例，被创建的实例通常有共同的父类。从中可以看出，改模式的重要特点是有参数，并且根据参数来决定创建什么样的具体实例。（参考）



1. 工厂方法模式：定义一个创建一个对象的工厂接口，然后让每一个子类工厂创建一个自己的实例类。（参考）鼠标工厂父类有生产鼠标这个接口，戴尔鼠标工厂生产戴尔鼠标，联想鼠标工厂生产联想鼠标。所以是一个抽象产品类，派生出多个具体产品类；一个抽象工厂类，派生出多个具体工厂类。



1. 抽象工厂模式：定义一个创建一系列相关或者相互依赖对象的工厂接口，然后每个子类工厂创建自己的一系列实例类。（参考）但是知乎链接里的解释更形象，比如有一个生产键盘和鼠标的工厂接口，然后戴尔工厂类生产戴尔牌键盘和鼠标，联想工厂类生产联想牌键盘和鼠标。所以是多个抽象产品类，每个抽象产品类派生出多个具体产品类；一个抽象工厂类，派生出多个具体工厂类。



 



**策略模式：**依赖c++的多态，抽象类的指针可以访问所有子类对象，（纯虚函数），可以用一个指针访问所有策略的实现类



**单例模式：**单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式(不能让一个程序打开两次  如：不能同时打开2个迅雷  迅雷用的单例模式)

构造函数被声明为私有，不能直接实例化对象。方式，定义static静态指针，利用内置方法创建对象，因为是static类型，所以只能创建一个。（工厂模式多与单例模式结合使用，一般只有一个工厂就够用了；JVM运行环境，Runtime类也是单例模式）

饿汉模式：线程安全，对象在使用前已经创建出来了。

懒汉模式：非线程安全，需要加锁。

```C++
private:     
	构造;
private:     
	static 类名*p;     
	static mutex mtx; 
public:     
	static 类名* instance();         
	if(p == NULL){             
        mtx.lock();            
        if(p == NULL){                
            p = new 构造；            
        }            
        mtx.unlock();         
    } 
```



 

**访问者模式：**适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中(做任何更改不需要修改基类，不依赖虚函数)

 

**观察者模式：**定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。(QT的信号机制，Windows的消息机制都应用了观察者模式，还有订阅邮件，邮件到了就会给你发邮件)

 

**建造者模式：**使得产品内部表象可以独立地变化，客户不必知道产品内部组成的细节。可以强制实行一种分步骤进行的建造过程。用一个接口完成不同的操作，需要对客户的需求进行把握。(如：登陆QQ，自动选择所在地的服务器)

 

**解释器模式：**给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。(如：360读取lua脚本，这个细节的实现就是解释器模式)

 

**命令模式：**把发出命令的责任和执行命令的责任分割开，委派给不同的对象允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。(命令模式在客户端与服务器之间用的最多 (C/S架构))

 

**模板模式：**不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。(适用于本地化，做一个软件，在日本是日文，美国是英语...)

 

**桥接模式：**将抽象化与实现化脱离，使得二者可以独立的变化，也就是指在一个软件系统的抽象化和实现化之间使用组合聚合关系而不是继承关系，从而使两者可以独立的变化。(相当于配电脑去装机，把各个模块组合到一起)



**适配器模式：**把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。

 

**外观模式：**外部与一个子系统的通信必须通过一个统一的外观对象进行。每一个子系统只有一个外观类，而且此外观类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个外观类。(多个子系统方法都需要一个外观类统一管理，用统一的接口方便消费者使用)

 

**享元模式：**享元模式大幅度的降低内存中对象的数量，使用享元模式主要是为了优化内存，相同功能可以并行使用。

 

**原型模式：**允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。

 

**责任链模式：**在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。(例如：晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了)

 

**中介者模式：**中介者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。（如：TCP/IP打洞技术）

 

**装饰模式：**装饰模式以对客户端透明的方式扩展对象的功能是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。

 

**状态模式：**意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。(如：到了晚上12点要睡觉，到了早上8点要起床...这就是状态)

 

**合成模式：**将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。(用于树状结构)