## C++杂记：

1、有些小的注意的点，想想都觉得没什么意思，不过还是记下来看看。比如在判断时（‘A’ == x）这种风格更好，因为如果把==写成了=，会有编译器报错，给常量赋值。。。挺逗的。

***

2、int *p = 0;这句话的意思是，0被转换成int * 类型，表示空地址，被赋值给了p。

***

3、用亦或 ^ 交换两个变量，不用担心越界问题。另外两个相同的数相亦或，其值为零。

***

4、C++和C语言的区别：
C语言不支持重载。之所以C++支持重载，是因为编译器在编译过程中，将不同的重载函数存储成了不同的格式，void foo（int, int） =》 _foo_int_int；而C语言则只编译成了_foo。
C++提供了C连接交换指定符号extern“C”解决名字匹配问题。
ifndef/define/endif是条件编译的一种，防止头文件被重复引用，也防止重复定义（变量，宏，结构等）。

***

5、#define语法：习惯用大写字母表示宏定义；不能以分号结束；为避免简单替换造成的问题，要小心地把参数用括号括起来。
另外，表达式可能出现溢出的情况，可在后面加上下标表示（无符号）长整型UL。

```C++
#define SECONDS_PER_YEAR (60*60*24*365)UL
```

***

6、区分const和*的位置，来判断const修饰的是什么：
如果const位于星号的左侧，则const修饰指针所指向的变量；const int*  a == int const * a
如果const位于星号的右侧，则const修饰指针本身；int* const p
常量必须在声明时初始化。

const成员函数，在函数声明后，在函数体前，加const关键字，表示成员变量不可被更改。
const在函数声明前，表示函数的返回值为常量。

const与#define相比有什么不同：
C++中两者皆可使用（但C++中约定：涉及常量，只用const常量，不用宏常量），C中没用const关键字。
const常量有数据类型，而宏常量没有数据类型。编译器会对const常量做类型安全检查，而对#define只做简单字符替换（产生意想不到错误）。
C++程序中，在类里面的数据成员加上mutable，修饰为const的成员函数，可修改此数据成员。例：

```C++
mutable int m_count;
int incr() const{
    return ++m_count;
}

```

***

7、sizeof和strlen：
sizeof是运算符，strlen是函数。
sizeof操作符的结果类型是size_t（头文件中typedef  unsigned int  size_t），不会越界。
sizeof可用任何类型做参数，strlen只可以传入char* 类型。
数组做sizeof的参数不退化，传递给strlen就退化为指针。
sizeof编译时计算，strlen运行时计算（一说sizeof可以定义数组，但也不一定，跟编译器有关）。
sizeof后如果是类型则必须加括号，如果是变量名可以不加括号。（因为sizeof是操作符，而非函数）。
sizeof后加静态数组，返回数组大小；但动态数组，只返回指针大小。
数组作为参数传递给函数时，会退化为指针，sizeof给出其指针大小。
fun(char[8]) == fun(char*)

内存对齐实际上是与CPU存取速度相适应的，对齐后CPU存取速度快。
sizeof操作符不能用于函数类型，不完全类型（指具有未知存储大小数据的数据类型，如未知内容的结构，联合类型，void类型。。。）或位类型。
对函数使用sizeof，在编译阶段，会被函数返回值的类型取代。

```C++
int f1(){return 0;}
cout << sizeof(f1()) << endl;
//输出为4，f1()的返回值为int，所以实际上被替换为sizeof(int)。
```

空类型所占空间为1， 单继承的空类空间也为1，多重继承的空类空间还是1，虚继承的空间为4。

```C++
***
```

8、sizeof不是函数，也不是一元运算符，它是个类似宏定义的特殊关键字（在编译阶段被替换）。sizeof（）括号内的内容在编译过程中不会被编译，只会被替代类型。

```C++
int a = 8;
sizeof(a) == sizeof(int)
sizeof(a=6) == sizeof(int)
cout << a;
//返回a仍为8，因为a=6的语句没有被执行。
sizeof(unsigned int) == sizeof(int)
//unsigned影响的只有高bit的含义，并不影响数据长度。
```

***

9、内联函数和宏定义的差别：
内联函数和普通函数相比，可以加快程序运行的速度，因为不需要中断调用，在编译的时候，内联函数可以直接镶嵌到目标代码中。而宏是在预编译阶段的简单替换。
内联函数要做参数类型检查，宏则没有。
inline嵌入代码，并非跳转，而是直接把代码写到那里（用空间，来换回跳转消耗的时间）。

***

10、inline一般使用的情况：
一个函数被不断重复调用。
函数只有简单几行，且没有while，for，switch语句。
inline的声明与定义须放在一起。

```C++
inline void foo(int x, int y){return x+y;}
```

***

11、指针和引用的差别：（类型* const ≈ 类型&）
非空区别。在任何情况下，都不能使用指向空值的引用。
合法性区别。在使用引用之前不需要测试其合法性，但指针须测试其是否为空。
可修改差别。引用总是指向其初始化时被指向的对象，不能更改，但指针可以被重新赋值指向另一不同的对象。
应用区别。指针的应用情况如下，否则偏向使用引用：
考虑到存在不指向任何对象的情况。
需要能够在不同时刻指向不同对象的情况。

***

12、例题，下面代码的输出结果为：

```C++
#include<stdio.h>
class A{
    public:
        A(){m_a = 1; m_b = 2;}
        ~A(){};
        void fun(){printf("%d%d",m_a,m_b);}
    private:
        int m_a;
        int m_b;    
};
class B{
    public:
        B(){m_c = 3;}
        ~B();
        void fun(){printf("%d",m_c);}
    private:
        int m_c;    
};
void main(){
    A a;
    B* pb = (B*)(&a);
    pb->fun();
}
//结果为1。
```

野蛮的方式将a地址的内容看成是B类的对象，pb指向的是A类的内存空间。
pb指向的是对象的内存首地址，比如0x22ff58，当pb->fun()调用B::fun()来打印m_c时，编译器对m_c的认识就是m_c距离对象的偏移量是0，于是打印了a的首地址变异量0x22ff58 + 0的变量值。所以打印的是m_a的值。

***

13、指针常量和常量指针：
const char const * p == const char* p 常量指针，指向const char类型。
char * const p 指针常量，指向char类型。
const char * const p 指向常量的指针常量。

***

14、函数指针（基本最复杂的情况了）：
int (*(*F)(int, int))(int) :F是一个函数的指针，指向的函数的类型是有两个int类型的参数，并且返回一个函数指针的函数，返回的函数指针指向有一个int参数并且返回int的函数。

***

15、迷途指针：
迷途指针也称悬浮指针，时空指针。
是对一个指针进行delete 操作后，但没有把它置为空时产生的。
而后如果没有重新赋值，就直接使用它，会引起不可预料的后果。

如果在删除了一个指针后又把它删除了一次（重复删除），程序会变得非常不稳定

***

16、malloc/free和new/delete有什么区别：
malloc和free是语言标准库函数，new和delete是c++运算符。
new可以完成动态内存分配并且初始化的任务，delete可以完成清理与释放内存的任务。

***

17、句柄：
句柄首先是一个32位整数uint。
因为在windows内存管理的工程中，空闲对象会被系统暂时释放掉，然后在需要访问时再重新从内存中新建，所以对象的物理地址是变化的，其实程序是无法通过物理地址来访问对象的（而是通过句柄），有了句柄会检查对象列表从而访问对象。
句柄是一种指向指针的指针。
windows内存管理器会在内存中来回移动对象，为了能够高效的使用内存（内存整理）。对象的地址可能会发生变化，而句柄则一直不变，句柄内的值会时刻跟踪对象的地址。
windows系统用句柄标记系统资源，隐藏系统的信息。

***

18、this指针：
关于this指针有一个比较有趣的比喻：在房子外面，你可以看到房子的全貌；但如果你进了房子，就只能看到桌子、椅子、地板等，再也看不到房子的全貌了。
this指针本质是函数的参数，是由编译器隐藏起来的。
this指针在成员函数开始前构造，在成员函数结束后清除。与其他参数一致。
this指针不占据对象的空间，只是当前对象被他指向。
this指针的储存位置因编译器不同而不同。
this指针只有在成员函数中才有定义。

***

19、STL容器和模板：
产生的意义：不要重复造轮子。
容器是包含其他对象的对象。
顺序容器：提供顺序访问和随机访问。
关联容器：限制访问的方式（比如键值访问）。
容器适配器：栈，队列等等。
注意容器中对象的深浅拷贝问题（系统自身提供的拷贝构造函数是浅拷贝）

***

20、泛型与模板：
泛型编程：以算法为起点，忽略具体细节。
模板：我自己认为是泛型编程这个概念在C++中的实现方式。主要为模板函数和模板类。
类模板的特化与偏特化：就像函数模板重载那样，你可以通过特化（偏特化）类模板来为特定的类型指定你想要的行为。类模板的特化（偏特化）只需要模板名称相同并且特化列表<>中的参数个数与原始模板对应上即可，模板参数列表不必与原始模板相同模板名称相同。一个类模板可以有多个特化，与函数模板相同，编译器会自动实例化那个最特殊的版本。

```C++
#include <typeinfo>

template<typename T> //基本模板
class S {
public:
   void info() {   
       printf("In base template\n"); 
   }
};

template<> //特化
class S<int> { 
public:
   void info() {
       printf("In int specialization\n");
   }
};

template<typename T> //偏特化
class S<T*> {
public:
   void info() {
       printf("In pointer specialization\n");
    }
};
```

***

21、面向对象基础：
有一个也比较有趣的比喻：面向过程就好比编年体，面向对象好比纪传体。
面向对象的优势：可复用，可扩展，易维护。
面向对象的三大原则：封装，继承，多态。
里氏代换原则（里斯科夫代换原则）：子类型必须能够替换他们的父类型
开闭原则：软件对扩展开放，对修改应该是关闭的。
对于一个空类型，编译器默认产生四个成员函数：默认构造函数、析构函数、拷贝构造函数、赋值函数。
C++中的结构体struct和类class有什么区别：默认访问权限不同，其余均相同。听到一个比较有趣的回答struct关键字在C++中的唯一作用，就是让C程序员有个归属感。

***

22、成员变量：
static修饰的静态成员变量，如想要限制对象的访问，须将它设为private或者protected
const修饰的常量成员，须在成员初始化表中初始化，或者将其设为static的。

```C++
class A{
    static const int size = 9;
}
```

***

23、构造函数和析构函数：
构造函数为什么不能是虚函数：构造函数是建立一个对象而存在的，如果创建一个对象，必须了解所要创建对象的准确类型。而虚函数的概念是，知道接口（基类的类型），而不知道子类的具体类型，在运行时动态绑定，这与创建对象的过程相悖。
容易混淆的，在构造函数中是否可以调用虚函数：可以，但没实际意义，因为没构造完，不采用动态绑定。
析构函数为什么通常是虚函数：因为多态的存在，基类的指针往往指向派生类的对象，对于派生类的析构，如果不是虚函数，则调用的是基类的析构函数，造成内存泄漏。（析构函数可以是内联函数）
为什么不把所有函数设为虚函数：因为占空间，对象中多存了虚函数指针，类也要维护虚函数表，会产生额外的系统开销。
**explict关键字，消除隐式的类型转换**（P122例题，这就不多总结了）。
派生类中的虚函数的声明必须与基类中的定义方式完全匹配，但是有一个例外，返回对基类型的引用或指针的虚函数。

```C++
Base* Base::copy(Base*);
Derived* Derived::copy(Derived*);
```

***

24、多态：（==晚绑定）
又有一个还算不错的比喻：开门，开窗户，开电视。这里的“开”就是多态。
一句话总结：允许将子类型的指针赋给父类型的指针。（但好像是用引用不行，因为派生类对象初始化基类的引用，会把不属于基类的成员截断。）
多态的目的，接口重用。

***

25、友元：
规避类型检查等因素，使得非成员函数可以访问类内的成员。
友元函数是一种定义在类外部的普通函数，但它需要再类内进行说明。friend关键字。
友元也可以是一个类。

***

26、异常：
构造函数中抛出异常：有必要的，如果对象未构造出来（或未完全构造出来），在构造函数中不抛出异常，则编译器认为可以正常执行，可能会造成未知后果。另外在对象析构的过程中可能会释放未知空间。所以一般编译器会保持一致性，要么完全构造，要么完全失败。
一些结论：
C++中通知对象构造失败的唯一方法，就是在构造函数中抛出异常。
对象的部分构造还是比较常见的，异常发生点随机，需要程序员谨慎处理。
对象发生部分构造时，已经构造完毕的部分会逆序地被析构，这样会保证未被构造的成员不会被析构。

***

27、派生类为什么能操作基类成员：
类对象操作时在内部构造时会有一个隐性的this指针。派生类对象中的this指针的范围会覆盖到基类，所以派生类能对基类成员进行操作。

***

28、覆盖：

```C++
class A{
    protected:
        int m_data;
}
class B: public A{
    protected:
        int m_data;
}
class C: public B{
    protected:
        int m_data;
}
```

这段代码，构造函数从最初始的基类开始构造，各个类的同名变量没有形成覆盖，都是单独的变量。
可以使用类名受限访问，如A::m_data。

**覆盖指的是子类覆盖父类函数（被覆盖），特征是：**
	分别位于子类和父类中
	函数名字与参数都相同
	父类的函数是虚函数（virtual）
**与之相对应的是隐藏的概念：**
	隐藏指的是子类隐藏了父类的函数（还存在），具有以下特征：
		子类的函数与父类的名称相同，但是参数不同，父类函数被隐藏
		子类函数与父类函数的名称，参数都相同，但是父类函数没有virtual，父类函数被隐藏。

IF 子类的函数与父类的名称相同，但是参数不同:
　　父类函数被隐藏
ELSE IF 子类函数与父类函数的名称相同&&参数也相同&&但是父类函数没有virtual:
　　父类函数被隐藏
ELSE IF 子类函数与父类函数的名称相同&&参数也相同&&但是父类函数有virtual:
　　父类函数被覆盖

***

29、继承：
公有继承：就像是三口之间的小孩，几乎享有父母的一切（public，protected），但是父母还有一点点隐私（private）不能被小孩知道。
私有继承：就像是离家出走的小孩，一个人漂泊在外，无法拥有父母的权力，财富。但即使这样，身体中留着父母的血液，行为中又有与父母相似的成分。

***

30、继承的访问限制：
分三部分，对基类对象而言，对派生类而言，对派生类对象而言：
**公有继承（public）:**
	基类成员对于其派生类的可见性：public、protected成员可见，private成员不可见。
	基类成员对于其派生类对象的可见性：public成员可见，protected、private成员不可见。
**保护继承（protected）：**
	基类成员对于其派生类的可见性：public、protected成员可见，private成员不可见。
	基类成员对于其派生类对象的可见性：都不可见。
**私有继承（private）：**
	基类成员对于其派生类的可见性：public、protected成员可见，private成员不可见。
	基类成员对于其派生类对象的可见性：都不可见。

***

31、?: 和 if-else的效率：
**先放结论：**
	多用三目，少用if-else
	如果用if，把概率大的放前面

**下面是原理：**
	程序运行时，处理器会通过并行运算而加速运行，当遇到选择支时则会停下判断 (例如高速行驶的大卡车遇到了分岔路）

​	if-else 是先赋值再运算，为了节省时间，分支预测会先猜测运行 if 还是 else 并继续运行 (默认是if)，若猜对则因并行运算而节省时间，若猜错则因消除运算而耗费时间。 (卡车直接冲向一边康康可不可以走通,如果可以则继续走，如果不可以则回头走另一条路)(成本是回到分岔处的时间）

​	三目?: 是先运算再赋值，遇到选择支时停止并行并判断条件。(在分岔处停下康地图) (成本是重新加速需要的时间)
​	在多数情况下，运算结果为0与为1的可能相近，分支预测&并行运算 会比三目耗费更多的时间，所以**应更多的使用三目**。
​	在一些情况下，**运算结果大多为0或大多为1（80+%）**，这时 分支预测&并行运算 的损耗远小于三目，所以应选择 if-else

***

32、虚函数继承和虚继承：
	所谓虚函数继承就是派生类继承基类的虚函数，然后派生类可以override重写这个虚函数实现运行时多态。使用类对象的虚函数指针和类的虚函数表来实现的。（虚函数的不仅增加了存储开销，还增加了运行时的寻址时间，在运行时根据虚指针来定位函数地址。）

虚继承则是为了解决多重继承中的菱形继承问题，提供的一种方法，A->B;A->C; B,C->D。可以把B、C继承A的情况声明为虚继承，这样在D中就只有A中成员的一个拷贝了。（而且存放的顺序变成了，B、C、D、A。）

***

33、C++为什么会保留多重继承：
	首先要声明的是多重继承本身并没有什么问题。只是在语言的标准中支队语义做了规定，对编译器的细节没有规定。所以编译器在实现多重继承时会出现和人们预期有差距的事情。比如内存分布的位置等。

​	另外C++是为实用性存在的，注重效率，但可能会出现各种缺陷，但C++并不回避这些缺陷，只是把这些问题交给了程序设计者，从而给大家更多的自由。

***

34、继承和组合：
	刚才提到了继承的一些缺陷，虽然并非致命问题，但在编程过程中会有些不便。所以基本上除了必要情况，明确“组合优于继承”这句话。

​	继承是“是一种”的关系，而组合是“有一个”。但也不是在所有情况下都对应，比如鸵鸟和鸟类，更像是“有一种”的关系，具体情况要具体分析。

***

35、C++中如何阻止一个类被实例化：
	使用抽象类；
	将构造函数声明为私有。

***

36、设计一个类：只能在堆上创建对象？只能在栈上创建对象？

​	在C++中，类的对象建立分为两种，一种是静态建立，如A a；另一种是动态建立，如A* ptr=new A；这两种方式是有区别的。

​	静态建立一个类对象，是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。使用这种方法，直接调用类的构造函数；

​	动态建立类对象，是使用new运算符将对象建立在堆空间中。这个过程分为两步，第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。这种方法，间接调用类的构造函数。

**只能在堆上创建：**

​	将类的析构函数是私有，编译器无法调用析构函数来释放内存（也即编译器实际是算作类外的某种对象，无法直接访问非public成员）。所以，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。

```C++
class  A  {  
    public :  
        A(){}  
        //类中必须提供一个destory函数，来进行内存空间的释放。
        //类对象使用完成后，必须调用destory函数。 
        void  destory(){ delete   this ;} 
    private :  
        ~A(){}  
};  
```

但这种方法没办法解决继承的问题，所以改进是把构造函数和析构函数都设为protected，然后提供一个public的static函数来完成构造，这样不使用new，而是使用一个函数来构造，使用一个函数来析构。

```C++
class  A  {  
    protected :  
        A(){}  
        ~A(){}  
    public :  
        static  A* create(){  
            return   new  A();  
        }  
        void  destory(){  
            delete   this ;  
        }  
};  
```

**只在栈上创建：**

​	只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。将operator new()设为私有即可，即重载new运算符设为私有。 

***

37、C++引入的额外开销：
**编译时开销：**

​	模板，类层次结构，强类型检查等新特性，以及大量使用这些新特性的C++模板、算法库都增加了编译器的负担。但减少了程序员的工作量。
**运行时开销：**

​	虚基类（虚继承时被virtual关键字修饰的基类）
​	虚函数
​	RTTI（全程是Runtime Type Information，比如dynamic_cast和typeid）dynamic_cast 用于在类层次结构中漫游，对指针或者引用进行自由的向上，向下或交叉转化。typeid用于获取一个对象或者引用的确切信息（根据type_info对象）。
​	异常
​	对象的构造和析构

***

38、四种类型转化符：
	dynamic_cast<目标*><源指针>：用于将基类对象的引用或者指针转化为用以继承层次中的其他类型的引用或指针。（**会做安全检查**）
	static_cast：基础类型的转化，但不能把struct转化为int ，或者把double转化为指针类型。有越界检查，类型检查等。
	const_cast：用于加上或者除去const属性
	reinterpret_cast：将操作数的位模式提供较底层的重新解释。用于无任何关联类型的转化。



补充：

​	多态：将子类的指针赋给父类的指针

​	dynamic_cast：子类的指针转化为父类指针（大的区域->小的区域）

***

39、无法重载的运算符：
?:、.、.*、::、sizeof
重载运算符一般有两种形式：成员函数形式，友元函数形式。

***

40、暂时最后一个问题：一个类的空指针能否调用这个类的成员函数？

```C++
#include<iostream>
#include<string>
using namespace std;
class A{
  public:
      virtual void foo(){cout << "A::foo" << endl;}
      void pp(){cout << "A::pp" << endl;}  
};
class B: public A{
  public:
      void foo(){cout << "::foo" << endl;}
      void pp(){cout << "B::pp" << endl;} 
      void FunctionB(){cout << "Excute FunctionB!" << endl;} 
};

int main(){
    A a;    //可改为 B a;就解决问题了
    A *pa = &a;
    pa->foo();
    pa->pp();
    (dynamic_cast<B*>(pa))->FunctionB();      //1
    (dynamic_cast<B*>(pa))->foo();            //2
    (dynamic_cast<B*>(pa))->pp();             //3
    (*pa).foo();
    return 0;
}
```

​	因为a是基类的对象，dynamic_cast<B*>(pa)将返回空指针 == （B* sumnull = NULL）。
但1、3可以通过运行，因为这两个函数未使用任何成员数据，也不是虚函数，不需要this指针，也不需要动态绑定，可正常运行。（静态绑定的，编译器为了提升效率，会在编译时提前绑定好，运行时不进行检查，所以能直接运行，是某种trick）
2将会崩溃，因为调用了虚函数，编译器需要根据对象的虚函数指针查找虚函数表，此时为空，为非法访问。

​	这篇博客从底层汇编解释了原因https://www.cnblogs.com/kwang-cai/articles/5454641.html：
对于类成员函数而言，并不是一个对象对应一个单独的成员函数体，而是此类的所有对象共用这个成员函数体。 当程序被编译之后，此成员函数地址即已确定。而成员函数之所以能把属于此类的各个对象的数据区别开, 就是靠这个this指针。函数体内所有对类数据成员的访问， 都会被转化为this->数据成员的方式。

​	而一个对象的this指针并不是对象本身的一部分，不会影响sizeof（“对象”）的结果。this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。

​	对于上面的例子来说，this的值就是Null。对于是静态函数，编译器不会给它传递this指针，所以那行代码可以正确调用；对于1、3两个成员函数，虽然编译器会给这两个函数传递this指针，但是它们并没有通过this指针来访问类的成员变量，所以能够调用。而2不能调用，主要是因为this指针指向对象的虚指针的位置，对象为NULL，没有生成虚指针，所以不能调用。

总之有两点不能调用：**传入成员变量，使用虚函数指针**。

***

41、接explicit关键字：

C++发生隐式转化的情况：

- 混合类型的算术计算
- 不同类型的赋值操作
- 函数参数传值
- 函数返回值

隐式类型转化的风险（**一般存在于自定义的类构造函数中**）：

**按照默认规定。只有一个参数的构造函数也定义了一个隐式转化，将该构造函数对应的数据类型转化为**<u>该类的对象</u>。

```C++
class Test{ 
    public:   
    	Test(int a);   
    	bool isSame(Test other){     
            return m_val == other.m_val;   
        }   
    private：   
        int m_val; 
}  
//如下调用： Test a(10); If(a.isSame(10)) 
//该语句将返回true 
//本来用于两个Test对象的比较，竟然和int类型相等了。 
//这里就是由于发生了隐式转换，实际比较的是一个临时的Test对象。 
//这个在程序中是绝对不能允许的。 

class Test{     
	explicit Test(int a);     
	…… 
} 
```

禁止方法，使用explicit关键字修饰带参的构造函数；

***

42、volatile关键字（易变的，不稳定的）：

一个被定义为volatile的变量是说这个变量可能会被意想不到地改变。这样编译器就不会去假设这个变量的值。每次优化器用到这个变量的时候，会去重新读取这个变量的值，而不是读取保存在寄存器里面的备份。

一句话：它用来解决变量在“**共享**”环境下容易出现读取错误的问题。

使用场景：多线程应用中被几个任务共享的变量。