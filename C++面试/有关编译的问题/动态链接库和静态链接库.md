##### **1 静态链接库的优点：**

​	(1) **代码装载速度快，执行速度略比动态链接库快**；动态连接库需要寻址操作才能确定其中调用的函数，而静态链接库中的函数在编译时就确定了调用的函数，因此，在效率上，动态库比较慢

​	(2) 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，**可避免DLL地狱**等问题。

​	注：**DLL Hell 是指当多个应用程序试图共享一个公用组件（如某个动态连接库（DLL）或某个组件对象模型（COM）类）时所引发的一系列问题。最典型的情况是，某个应用程序将要安装一个新版本的共享组件，而该组件与机器上的现有版本不向后兼容。虽然刚安装的应用程序运行正常，但原来依赖前一版本共享组件的应用程序也许已无法再工作。**



##### **2 动态链接库的优点：**

​	(1) **更加节省内存并减少页面交换**；Y个程序中使用了相同的代码（假设这部分代码占用X个内存页），如果使用的是静态链接，这些相同的代码在各程序运行时必须重新加载到内存，那么Y个程序加载这部分代码会至少造成 Y*X 次缺页。如果使用的是动态链接库，运行这些程序时，这个动态链接库可能只需要被加载到内存一次，最少可能只造成 X 次缺页。当然肯定和内存的实际使用情况有关，这只是假设内存足够的情况下。

​	(2) **DLL文件与EXE文件独立**，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而**极大地提高了可维护性和可扩展性**；

​	(3) **不同编程语言编写**的程序只要按照函数调用约定就可以调用同一个DLL函数；

​	(4) 适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。



##### **3、不足之处对比：**

​	(1) 使用静态链接生成的可执行**文件体积较大**，包含相同的公共代码，造成浪费；

​	(2) 使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；**速度比静态链接慢**。当某个模块更新后，如果新模块与旧的模块**不兼容**，那么那些需要该模块才能运行的软件，统统撕掉。这在早期Windows中很常见。



##### **4、静态库 .lib文件到底是什么？**

​	静态lib文件实际上就是**任意个obj文件的集合**，而obj文件就是cpp文件编译之后产生的一种文件，一个cpp文件编译之后只会产生一个obj文件，而多个obj文件就可以连接生成lib文件。如果你工程里只有一个lib.h和lib.cpp，那么编译后产生的lib文件实际上就是lib.obj文件的一个集合，但是如果你工程里还有其他的很多个cpp文件，那么就会在编译之后生成许多obj文件，然后最终只链接生成一个lib文件。

​	所以，**静态lib文件实际上是包含了所有的导出声明和实现**。你如果把这个lib文件链接到自己的程序之后，这个lib文件中的所有代码都会嵌入进来，哪怕你只用到了其中一部分，剩下没用到的也进了你的代码。



##### **5、动态链接库 .dll是什么？**

​	**dll其实就是exe，只不过它没有main函数，所以不能单独执行而已**。事实上， 在实际的使用过程中我们也发现，很多应用程序都并不是一个完整的单独可执行文件，它们被分割成一些单独的相对对立的动态链接库，只有在执行应用程序的时候，用到的dll才会被调用。这也就是为什么你经常打开某些程序，会出现“无法加载XXX.dll”的原因了

​	“动态链接”这几字指明了DLLs是如何工作的。对于常规的函数库，链接器从中拷贝它需要的所有库函数，并把确切的函数地址传送给调用这些函数的程序。**而对于DLLs，函数储存在一个独立的动态链接库文件中。**在创建Windows程序时，链接过程并不把DLLs文件链接到程序上，直到程序运行并调用一个DLLs中的函数时，该程序才要求这个函数的地址。此时Windows才在DLLs中寻找被调用函数，并把它的地址传送给调用程序。采用这种方法，DLLs达到了复用代码的极限。 

​	动态链接库的另一个方便之处是对动态链接库中函数的修改可以自动传播到所有调用它的程序中，而不必对程序作任何改动或处理。DLLs不仅提供了函数重用的机制，而且提供了数据共享的机制。任何应用程序都可以共享由装入内存的DLLs管理的内存资源块。只包含共享数据的DLLs称为资源文件。



##### **6、导出和导入函数的匹配**

​	**DLL文件中包含一个导出函数表。这些导出函数由它们的符号名和称为标识号的整数与外界联系起来。** 

​	**函数表中还包含了DLL中函数的地址。**当应用程序加载DLL模块时时，它并不知道调用函数的实际地址，但它知道函数的符号名和标识号。动态链接过程在加载的DLL模块时动态建立一个函数调用与函数地址的对应表。如果重新编译和重建DLL文件，并不需要修改应用程序，除非你改变了导出函数的符号名和参数序列。



##### **7、无法启动应用程序，因为计算机中丢失xxx.dll的解决：**

​	在编译链接c++带有dll库的应用程序时，如果dll所在的目录和可执行文件所在的目录不在同一个目录，或者是不在系统的环境变量path所在的目录内， 这时一般要求修改系统的环境变量，或者将dll库复制到exe文件所在的目录，但是这样感觉不要好，可以采用另一种方便的方法，就是通过修改vs项目配置里面的环境变量： xxx具体项目 -> 属性 -> 配置属性 -> 调试 ->环境变量(Environment) -> 添加 ->path=%path%;..\bin; 其中../bin/就是添加的环境变量,然后项目就会自动在..\bin\查找是否有dll文件。